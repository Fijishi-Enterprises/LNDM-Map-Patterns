---
title: "Get Started with landscapemetrics"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    html_preview: false
vignette: >
  %\VignetteIndexEntry{Get Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load_libraries_hidden, eval=TRUE, echo=FALSE, message=FALSE, results='hide'}
library(landscapemetrics)
library(ggplot2)
library(patchwork)

landscape_plot <- landscapetools::util_plot(landscape) + theme_void() + guides(fill = FALSE) + coord_equal()
```

# Using **landscapemetrics**

The functions in **landscapemetrics** starts with `lsm_` and next are named based on a combination of abbreviations describing the scale (patch - `p`, class - `c` or landscape - `l`) and metric they calculate:

```
# landscapemetrics
lsm_"level"_"metric" example:

# Patch level
## lsm_p_"metric" example:
lsm_p_enn()

# Class level
## lsm_c_"metric" example:
lsm_c_enn()

# Landscape level
## lsm_p_"metric" example:
lsm_l_enn()
```

...and they return a tibble with the same columns:

<p style="text-align:center;">

| layer  | level | class | id | metric | value
| ------------- | -------------  | ------------- | ------------- | ------------- | ------------- | 
| 1 | patch  | 1 | 1 | landscape metric | x |
| 1 | class  | 1 | NA | landscape metric | x |
| 1 | landscape  | NA | NA | landscape metric | x |

</p>

A possible use case is that you would load your spatial data, calculate some landscape metrics and then use the resulting tibble in further analyses.

```{r, message=FALSE}
# load packages
library(landscapemetrics)
library(raster)
library(dplyr)

# Import raster
landscape_raster <- landscapemetrics::landscape
# for local file: raster("pathtoyourraster/raster.asc")
# ... or any other raster file type, geotiff, ...

# Calculate all available landscape metrics 
landscape_raster %>% 
  lsm_p_perim()
```

## Important information about using **landscapemetrics**

- The resolution of a raster cell has to be in **meters**, as the package converts units internally and returns results in a square "area" for some metrics.

## Using **landscapemetrics** in a tidy workflow

### Pipe landscapes into the functions

Every function in *landscapemetrics* accept data as its first argument, which makes piping a natural workflow:

```{r} 
landscape %>% 
  lsm_p_enn()
``` 

### Use multiple metric functions

As the result of every function always returns a tibble, combining the metrics that were selected for your research question is straightforward:

```{r}
# bind results from different metric functions
patch_metrics <- dplyr::bind_rows(
  lsm_p_cai(landscape),
  lsm_p_circle(landscape),
  lsm_p_enn(landscape)
  )
# look at the results
patch_metrics 
```

## Connected labelling 

`landscapemetrics` makes internally heavy use of an implementatian of the connected labelling algorithm by Thell Fowler (https://github.com/Thell/ccloutline) and exports an reimplementation of this algorithm:

```{r eval=FALSE}
cclabel_landscape <- landscapemetrics::cclabel(landscape)
landscapetools::util_facetplot(cclabel_landscape, nrow = 1)
```

![](cclabel.png){width=100%}

## Visualizing patches

To visualize patches in a landscape and encode each patch with an ID that can be used to compare a landscape metric with the actual landscape you can use the auxiliary visualisation function `show_patches()`:

```{r eval=FALSE}
# show patch IDS
landscape_plot  + show_patches(landscape) + plot_layout(ncol = 1)
```
<center>
![](showpatches.png){width=75%}
</center>

We think, this helps a lot to get a better understandment of the landscape metrics and composition and configuration of the landscape of interest.
